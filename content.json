{"meta":{"title":"Elvis 筆記歸檔","subtitle":"讀書心得、技術筆記","description":"","author":"Elvis Huang (Aka Allen)","url":"https://korbat4625.github.io/youzi","root":"/youzi/"},"pages":[],"posts":[{"title":"Javasciprt 忍者開發技巧探秘 第二版 讀後整理系列 02-2 (函式隱含引數)","slug":"JS-note-02-2","date":"2020-07-22T13:30:00.000Z","updated":"2020-07-22T14:32:20.297Z","comments":true,"path":"2020/07/22/JS-note-02-2/","link":"","permalink":"https://korbat4625.github.io/youzi/2020/07/22/JS-note-02-2/","excerpt":"-“Javasciprt 忍者開發技巧探秘 第二版 “ 讀後整理系列 02-2(函數隱含引數) - 前言 今日小主題: 函數隱含引數 arguments","text":"-“Javasciprt 忍者開發技巧探秘 第二版 “ 讀後整理系列 02-2(函數隱含引數) - 前言 今日小主題: 函數隱含引數 arguments 正文 arguments 叫做隱含引數，為何這麼叫呢，因為它並不是函式宣告時定義的參數，而是函式被呼叫時默默地被傳給函式的引數。 感覺講起來有點太生硬了，白話一點，arguments本身所代表的即為所傳入引數的集合，直接上程式碼: 123456789101112function collection() &#123; console.log(arguments) let sum &#x3D; 0; for(let i &#x3D; 0; i &lt; arguments.length; i++) &#123; sum +&#x3D; arguments[i] &#125; return sum;&#125;let sum &#x3D; collection(10,8,6,4,2)console.log(sum) &#x2F;&#x2F;30 console.log(arguments) 時，發現他是降陣列一樣的結構，index從0開始，不過事實上他不是陣列，也別因為可以用length存取他就誤認為是陣列，當我們對arguments使用陣列方法時，會發現一點都不管用，而console arguments時也清楚地看見並沒有陣列的方法可用。 MDN: arguments 物件是一個對應傳入函式之引數的類陣列（Array-like）物件。 arguments還有一項特性，當我們改變他對應的索引值時，所對應到的參數也會跟著改變，別忘了arguments代表所傳入引數的集合，另外，改變參數本身的值也會改變對應的arguments。 123456789101112function collection(a,b,c) &#123; console.log(a,b,c) &#x2F;&#x2F; 這裡輸出 2 4 6 console.log(arguments) &#x2F;&#x2F; 而這裡輸出 2 4 6 8 10 arguments[1] &#x3D; 20 console.log(a,b,c) &#x2F;&#x2F; (對應的參數改變了) 2 20 6 c &#x3D; 30 &#x2F;&#x2F; 改變參數值 console.log(arguments) &#x2F;&#x2F; (對應的arguments也改變了) 2 20 30 8 10 &#125;collection(2,4,6,8,10) 直接運行上方程式碼，就可以很清楚的知道arguments是何物了，他是所傳入引數的集合，也具有和參數互相掛鉤的關係，不過當我們使用嚴格模式”use strict” 12345678910111213function collection(a,b,c) &#123; &quot;use strict&quot; console.log(a,b,c) &#x2F;&#x2F; 這裡輸出 2 4 6 console.log(arguments) &#x2F;&#x2F; 而這裡輸出 2 4 6 8 10 arguments[1] &#x3D; 20 console.log(a,b,c) &#x2F;&#x2F; (對應的參數沒有改變) 2 4 6 c &#x3D; 30 &#x2F;&#x2F; 改變參數值 console.log(arguments) &#x2F;&#x2F; (對應的arguments也沒有改變) 2 20 6 8 10 &#125;collection(2,4,6,8,10) 使用嚴格模式，兩者就不互相掛勾了，參數怎麼改，arguments怎麼變，都不會互相影響。 # 結尾 這篇到這邊，下一篇寫不定參數，應該還會繼續02-X系列，因為都是相關的內容，貌似也有一點歷史的沿革性，最近在思考是否要把內容移駕到google的firebase服務裡面，要做的事情有點多，所以後續的更新就變成沒辦法每星期一篇，多多見諒啦~~","categories":[],"tags":[],"author":"Elvis Huang (Aka Allen)"},{"title":"Javasciprt 忍者開發技巧探秘 第二版 讀後整理系列 02-1 (函式屬性)","slug":"JS-note-02-1","date":"2020-07-09T14:28:00.000Z","updated":"2020-07-09T15:10:35.412Z","comments":true,"path":"2020/07/09/JS-note-02-1/","link":"","permalink":"https://korbat4625.github.io/youzi/2020/07/09/JS-note-02-1/","excerpt":"-“Javasciprt 忍者開發技巧探秘 第二版 “ 讀後整理系列 02-1(函數屬性) - 前言 今日小主題: 函數屬性 由於最近回家在研究Vue CLI + Router的部分，所以更新的篇幅會比較小一點，今日主要帶來上次在工作中有使用到函式屬性的部分，之後若有機會，也會順便更新一下自己搭建的Router應用。","text":"-“Javasciprt 忍者開發技巧探秘 第二版 “ 讀後整理系列 02-1(函數屬性) - 前言 今日小主題: 函數屬性 由於最近回家在研究Vue CLI + Router的部分，所以更新的篇幅會比較小一點，今日主要帶來上次在工作中有使用到函式屬性的部分，之後若有機會，也會順便更新一下自己搭建的Router應用。 正文 上次工作中的一個小環節，我需要將此套件sorting的部分做個小修改，由於套件行為只有升序降序來回切換，而需求需要點到第三下的時候取消掉。 這是套件修改前的狀態: 這是套件修改後的狀態: 因為套件本身並沒有能完成需求的一件式設定，所以必須使用套件提供的排序觸發事件sortingChanged來編寫行為 : 這是透過函式屬性的方式完成的關鍵代碼: ctx是事件觸發時的物件，內部包含一些狀態資訊，結尾的this.sortingChanged.cache是我為函式動態創建的cache屬性，用來記錄這次排序欄位是什麼，以及比對下次的排序欄位。 整體的邏輯為: 123456789101112if (上次排的欄位快取 !&#x3D;&#x3D; 這次滑鼠點擊排的欄位) &#123; 計數器 &#x3D; 1&#125; else &#123; 計數器 + 1&#125;if (計數器 &#x3D;&#x3D;&#x3D; 3) &#123; 計數器歸零 清空排序狀態&#125;更新快取排序欄位 結語 自己在使用函式屬性的經驗上，可以說是零，因為之前完全沒有想到函式本身也是物件這一事實。因此在忍者書讀到函式屬性的時候，著實有點小驚訝，對書中函式屬性的小範例印象深刻，也感嘆到對於單單的使用網路上的免費資源自學過來，是很容易漏掉東西的 ( 比如說MDN的函式文檔根本沒有細說到函式屬性的部分 ) ，所以非常地慶幸做了買書研讀的選擇，也這麼快地對書中內容有所使用。","categories":[],"tags":[],"author":"Elvis Huang (Aka Allen)"},{"title":"Javasciprt 忍者開發技巧探秘 第二版 讀後整理系列 02","slug":"JS-note-02","date":"2020-06-30T13:12:08.000Z","updated":"2020-07-02T14:03:17.825Z","comments":true,"path":"2020/06/30/JS-note-02/","link":"","permalink":"https://korbat4625.github.io/youzi/2020/06/30/JS-note-02/","excerpt":"-“Javasciprt 忍者開發技巧探秘 第二版 “ 讀後整理系列 02- 前言 今天開始進入JavaScript的領域…","text":"-“Javasciprt 忍者開發技巧探秘 第二版 “ 讀後整理系列 02- 前言 今天開始進入JavaScript的領域… 今日主題: 函式 在JavaScript中，函式是頭等公民、也可稱頭等物件(函式也是一種物件)、又稱一級函式、頭等函數。 wiki: 一級函式（first-class function）是指在程序設計語言中，函數被當作頭等公民。這意味著，函數可以作為別的函數的參數、函數的返回值，賦值給變量或存儲在資料結構中。 既然函式可以歸類為物件，那就代表他能夠做和物件一模一樣的事情，以下內容參考忍者書範例並重新編排內容及參雜個人解釋: 物件與函式皆可藉由實值 { } 建立 : 以物件來說，就是物件實字（Object literal）的意思 1234&#x2F;&#x2F; 物件: 一般像這種 &#123; &#125; 的方式來建立物件，就叫做物件實字建立法(這是非常官方及教科書的說法)，那我們用眼睛看他怎麼建立，發現其實就是直接定義一個物件內容的意思。&#123; ...&#125; 以函式來說，就是函式實字（Function literal）。 12&#x2F;&#x2F;函式: 函式實字建立法聽起來有夠彆扭，其實也是直接宣告函式及其內容...function plantATree() &#123;...&#125; 物件與函式皆可被 指派給變數、陣列資料項或其他物件的屬性 12345678910111213141516171819&#x2F;&#x2F; 指派給變數tree &#x3D; &#123; appleTree: 1&#125;&#x2F;&#x2F; 注意這種沒有函式名稱的指派就是常說的匿名函式plantATree &#x3D; function () &#123; return &#123; appleTree: 1 &#125;&#125;&#x2F;&#x2F; 指派給陣列tree &#x3D; [&#123;&#125;]plantATree &#x3D; [function()&#123;&#125;]&#x2F;&#x2F; 指派作為其他物件的屬性tree.data &#x3D; &#123;&#125;;plantATree.data &#x3D; function()&#123;&#125;; 物件與函式皆可 作為引數傳遞給函式 123456789101112&#x2F;&#x2F; 物件作為引數function plantATree(tree) &#123; tree.growUp &#x3D; true; return tree;&#125;tree &#x3D; plantATree(&#123;&#125;);&#x2F;&#x2F; 函式作為引數function plantATree(growUp) &#123; growUp();&#125;plantATree(function()&#123;&#125;); 物件與函式皆可 作為函式的回傳值 1234567function plantATree() &#123; return &#123;&#125;; &#x2F;&#x2F; 回傳物件&#125;function plantATree() &#123; return function()&#123;&#125;; &#x2F;&#x2F; 回傳函式&#125; 物件與函式皆擁有 可動態建立並指派的屬性 1234567&#x2F;&#x2F; 在物件上新增屬性let tree &#x3D; &#123;&#125;;tree.appleTree &#x3D; 1;&#x2F;&#x2F; 對函式新增屬性let plantATree &#x3D; function()&#123;&#125;;plantATree.appleTree &#x3D; 1; 至此可以做個整理，在JavaScript的世界中，頭等公民具有以下特點: 可藉由實值 { } 建立 可被指派給變數、陣列資料項或其他物件的屬性 可作為引數傳遞給函式 可作為函式的回傳值 擁有可動態建立並指派的屬性 其中可作為引數傳遞給函式將會是一個比較特別的特性，此特性將會帶來一個新的討論，也就是回乎函式(Callback Function) 回乎函式 Callback Function 關於回乎函式，我日前在 這本電子書 看到一段我覺得比較生活化的解釋: 有客戶打來電話給你，可是你正在電話中，客戶會留話說請你等會有空時再”回電”給它 而忍者書所說的是: 將函式作為引數傳遞給另一個函式，而在稍後的某個時間點，他可能會呼叫這個被傳入的函式，這是一種被稱為 “回乎函式” 的概念。 舉一個最常見的例子: 123456789&#x2F;&#x2F; 先宣告一個函式function plantATree() &#123; ... &#125;let button &#x3D; document.querySelector(&quot;#button&quot;);&#x2F;&#x2F; 對按鈕進行監聽，按下去時執行 plantATreebutton.addEventListener(&quot;click&quot;, plantATree); 看這個例子就可以知道，我們把函式plantATree當作引數傳入，按下按鈕後即執行此函式，這就是回呼的概念。 接下來再假設一個例子: 我們要蒐集4個輪子，如此才能組成1輛車，依照這樣的情境我們來寫一個回呼函式的例子，也就是說，當我得到4個輪子的時候，組成車子的函式就能夠被執行。 1234567891011121314151617181920212223242526272829&#x2F;&#x2F; 蒐集輪子的函式，參數為 buildACarfunction collectAWheel ( buildACar ) &#123; setInterval(() &#x3D;&gt; &#123; wheel++; if( wheel % 4 &#x3D;&#x3D;&#x3D; 0 ) &#123; buildACar(); &#125; &#125;, 1000);&#125;&#x2F;&#x2F; 製造車子的函式function prepareACar () &#123; car++; console.log(&quot;build a car! now we have &quot; + car + &quot; cars&quot;);&#125;let wheel &#x3D; 0;let car &#x3D; 0;&#x2F;&#x2F; 開始蒐集輪子，將製造車子的函式 prepareACar 作為引數傳入collectAWheel(prepareACar);&#x2F;&#x2F; 假如沒有定義 prepareACar，也可以像這樣直接傳入一個匿名函式的寫法&#x2F;*collectAWheel(function () &#123; car++; console.log(&quot;build a car! now we have &quot; + car + &quot; cars&quot;);&#125;);*&#x2F; 將程式碼運行後，每一秒都會console一條新的訊息，每秒車子都會增加一輛，符合了”稍後的某個時間點(一秒後)，會呼叫這個被傳入的函式(prepareACar)”的概念。 結尾 以上就是這篇的內容，下章節會是一個短章節，題目是函式的屬性，函式的屬性還滿少見的，一般都是使用物件的屬性，自己也是在看到忍者書的函式章節後才意識到函式有屬性這回事XD，前幾天工作的時候突然想到這件事，發現這個方式或許可以拿來用，覺得還蠻有趣的，下回再分享給大家。","categories":[],"tags":[],"author":"Elvis Huang (Aka Allen)"},{"title":"Javasciprt 忍者開發技巧探秘 第二版  讀後整理系列 01 ","slug":"JS-note-01","date":"2020-06-17T15:07:00.000Z","updated":"2020-07-02T13:58:40.505Z","comments":true,"path":"2020/06/17/JS-note-01/","link":"","permalink":"https://korbat4625.github.io/youzi/2020/06/17/JS-note-01/","excerpt":"-“Javasciprt 忍者開發技巧探秘 第二版 “ 讀後整理系列 01 - 前言 雖然網路上有很多相似的筆記，不過仍期勉自己能夠將整本讀完後，做一套完整的整理，將從以下幾點的概述，做為第一篇的開始，而從第二篇開始，即會開始加入較多的本書重點，也就是JavaScript程式語言本身 。","text":"-“Javasciprt 忍者開發技巧探秘 第二版 “ 讀後整理系列 01 - 前言 雖然網路上有很多相似的筆記，不過仍期勉自己能夠將整本讀完後，做一套完整的整理，將從以下幾點的概述，做為第一篇的開始，而從第二篇開始，即會開始加入較多的本書重點，也就是JavaScript程式語言本身 。 本篇將先探討 網頁生命週期 網頁及JavaScript執行順序 正文 網頁的生命週期 ，分為頁面建立 及 事件處理 兩階段，以下解說大致流程 : 首先要先知道有三個角色 : 客戶端(使用者) 、 瀏覽器 、 伺服器端。 當使用者打開瀏覽器輸入網址時，[瀏覽器] 會向後端 [伺服器] 請求頁面資訊，當 [瀏覽器] 接收到 [伺服器] 返回的頁面回應時，為網頁生命開始的瞬間，流程大致上為 : → [客戶端] 輸入網址至 [瀏覽器]→ [瀏覽器] 產生請求至 [伺服器]→ [伺服器] 執行某動作並將回應送回 [瀏覽器]→ [瀏覽器] 處理HTML CSS Javascript 並建立頁面顯示 (頁面讀取階段)，為生命週期的開始→ [瀏覽器] 開始監聽事件佇列(事件處理階段)→ [客戶端] 對網頁元素做點擊等等互動並產生事件(動作A)至→ [瀏覽器]→ [瀏覽器] 捕捉相對應點擊等事件，並做相對應事件處理(透過JavaScript處理事件，可能會有和伺服器溝通的部分)(動作B)隨後:→ 動作A→ 動作B→ 動作A→ 動作B … 如此反覆，直到使用者不再對網頁做操作並關閉時，此頁面就算結束生命週期，由流程來看，可以發現瀏覽器為客戶端及伺服器兩者溝通的橋樑。 以上為生命週期的簡易說明，講白了就是看見頁面即擁有生命，關掉頁面即結束生命。 # 細說 1: 頁面讀取階段 (此階段開始，要用一些程式碼的部分輔以解說，為求寫文效率，一些源碼的部分會有些微省略，比如&lt;!DOCTYPE html&gt; &lt;html&gt;...&lt;/html&gt;等，將不會每次都列入文中顯示) 頁面讀取階段，瀏覽器會解析一份文件內容(HTML)，並將之建立成文件物件模型(DOM)，然後依照此DOM的結構，將之渲染在瀏覽器畫面上而成為我們所看到的頁面，並且瀏覽器本身會提供一些API，供我們開發人員存取及操作這些網頁元素。 DOM的產生，是依照HTML，因此可以說HTML為DOM的藍圖，而開發人員負責編寫HTML，瀏覽器負責解析。 一般的HTML結構如下 : 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 重要 : 一行一行，由上而下 瀏覽器解析HTML的方式，如同大部分程式語言一樣，是一行一行，由上而下執行下來的，這裡不討論類似陳述式goto這種行為，而瀏覽器也不可能做這種事情。 在正文提到的網頁生命週期階段，其中有一階段為 : [瀏覽器] 處理HTML CSS Javascript 並建立頁面顯示 (頁面讀取階段) 既然瀏覽器是依照我們所編寫的HTML 一行一行，由上而下 的方式執行，那麼我們就可以來探討加入&lt;script&gt;標籤，並開始撰寫一些JavaScript程式碼的問題了。在插入script標籤並開始寫程式碼之前，我們必須提一些瀏覽器和JavaScript的小故事，隨後再讓我們回到程式碼的部分。 [瀏覽器和 JavaScript] JavaScript可以在許多環境中執行，像是執行在電腦桌面、Node.js，甚至還可做嵌入式系統，不過最初始的環境，以及目前普遍應用最多的，還是屬於最一開始讓JavaScript運行的始祖環境，也就是瀏覽器。 而瀏覽器中，有兩大物件十分的重要: window 與 document。這兩個物件並不屬於JavaScript，而是瀏覽器提供給JavaScript使用的物件，window 與 document 非常的古老，從20世紀末瀏覽器百家爭鳴、規則混亂的時代開始，各家瀏覽器都有實做他們，重要程度不言而喻，以至於被後來的W3C整合進初代標準中，屬於DOM Level 1，瀏覽器大戰的年代，有興趣者自行上網搜尋，由於本人並非該年代之人，因此無法述說詳盡XD。 window物件代表瀏覽器視窗本身，而document就是生長在window下，並依照HTML文件所建立出來的文件結構，DOM通常被用樹狀來解釋，因此有DOM Tree一說。我們可以直接在瀏覽器的除錯工具中輸入document，看看是否會顯示HTML的整份文檔內容 ! [DOM 區分為 DOM Core 及 HTML DOM] DOM Core 顧名思義就是 DOM的核心部分，他實際上是一些API，但其實DOM Core本身有在訴說一個底層的概念，也就是從根部(document)開始依照父子關係的架構延伸出一個個的節點，每個標籤都是一個節點並不斷地延伸到文件末端。我們可以利用 DOM Core 所提供的這些API，去取得DOM Tree的任何一個節點。 我們常常使用的getElementBy…系列，就是DOM Core，可以在 document物件上使用他，也可以在任何一個節點上使用，是瀏覽器提供的核心API ! 而 HTML DOM 就我看過W3C的理解來說是以 DOM Core為基底，延伸出對物件或元素節點，進行一切操作的辦法。 W3C: The HTML DOM is a standard object model and programming interface for HTML. It defines: The HTML elements as objects The properties of all HTML elements The methods to access all HTML elements The events for all HTML elements In other words: The HTML DOM is a standard for how to get, change, add, or delete HTML elements. Example: 123456789&#x2F;&#x2F; 先用DOM Core 取得id為appleTree的ul節點以做為起點let appleTree &#x3D; document.getElementById(&quot;appleTree&quot;); &#x2F;&#x2F; 再利用存取物件的.符號取得更深的節點，把第一個li的值改為 0&#x2F;&#x2F; appleTree.childNodes[0].childNodes[0].nodeValue &#x3D; 0; &#x2F;&#x2F; 也可在此節點上再用一次DOM Core，再用.innerText &#x3D; &quot;0 also&quot;&#x2F;&#x2F; 實際實驗可以看見第二個li的值也被更新了&#x2F;&#x2F; appleTree.getElementsByTagName(&quot;li&quot;)[1].innerText &#x3D; &quot;0 also&quot;; 如此就是我說的以 DOM Core為基底，延伸出對物件或元素節點，進行一切操作的辦法。 這是我自己的理解，若有其他想法也可以一起討論討論。或者也可以利用類似.childNodes…childNodes…childNodes…如此的方式不斷存取下去，也算是把HTML DOM的精神發揮到了極致…。 細說 2: 網頁及JavaScript執行順序 [回到文檔部分並加入一些內容] 1234567891011121314&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;ul id&#x3D;&quot;appleTree1&quot;&gt; &lt;li&gt;apple1&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;script&gt; let appleTree1 &#x3D; document.getElementById(&quot;appleTree1&quot;) console.log(appleTree1) &lt;&#x2F;script&gt; &lt;&#x2F;body&gt; 1&#x2F;&#x2F; output: &lt;ul id&#x3D;&quot;appleTree1&quot;&gt;..&lt;&#x2F;ul&gt; 以上面的程式碼來說，由於前面所說瀏覽器在解析文檔時是像程式語言一樣一行一行，由上而下 (我們現在要來證實這件事)，因此瀏覽器先將ul及其內容建構進DOM中，接下來遇到script標籤，即會開始執行內部的JS程式，document.getElementById所做的事情就是尋找到目前為止已經成為DOM Tree的任一節點 之元素，既然如此，我們把文檔改為以下內容: 1234567891011&lt;body&gt; &lt;ul id&#x3D;&quot;appleTree1&quot;&gt; &lt;li&gt;apple1&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;script&gt; let appleTree1 &#x3D; document.getElementById(&quot;appleTree1&quot;); let appleTree2 &#x3D; document.getElementById(&quot;appleTree2&quot;); console.log(appleTree1, appleTree2) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 1&#x2F;&#x2F; output: &lt;ul id&#x3D;&quot;appleTree1&quot;&gt;..&lt;&#x2F;ul&gt; null 因為document.getElementById所做的事情就是尋找到目前為止已經成為DOM Tree的任一節點 之元素，可以看見到目前為止在script之前，並沒有任何id = &#39;appleTree2&#39;的元素被解析進DOM Tree(可自行於除錯工具輸入document查看)，所以第二個值印出null。 那我們再把文檔改為: 123456789101112131415&lt;body&gt; &lt;ul id&#x3D;&quot;appleTree1&quot;&gt; &lt;li&gt;apple1&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;script&gt; let appleTree1 &#x3D; document.getElementById(&quot;appleTree1&quot;); let appleTree2 &#x3D; document.getElementById(&quot;appleTree2&quot;); console.log(appleTree1, appleTree2) &lt;&#x2F;script&gt; &lt;ul id&#x3D;&quot;appleTree2&quot;&gt; &lt;li&gt;apple2&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;&lt;&#x2F;body&gt; 1&#x2F;&#x2F;console.log輸出 : &lt;ul id&#x3D;&quot;appleTree1&quot;&gt;..&lt;&#x2F;ul&gt; null 發現輸出還是 null，因為appleTree2是在script內的JS程式碼執行後才被解析出來，一樣在script標籤之前我們看不見任何appleTree2的文檔內容，要得到appleTree2的內容，我們得遵守瀏覽器** 一行一行，由上而下 ** 的規則，才能在適當的時機來取得我們要的節點，既然如此，我們就遵守瀏覽器的行為，把程式碼改的稍微精準一些: 12345678910111213141516171819&lt;body&gt; &lt;ul id&#x3D;&quot;appleTree1&quot;&gt; &lt;li&gt;apple1&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;script&gt; let appleTree1 &#x3D; document.getElementById(&quot;appleTree1&quot;); console.log(appleTree1); &lt;&#x2F;script&gt; &lt;ul id&#x3D;&quot;appleTree2&quot;&gt; &lt;li&gt;apple2&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;script&gt; let appleTree2 &#x3D; document.getElementById(&quot;appleTree2&quot;); console.log(appleTree2); &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 123&#x2F;&#x2F; 分別輸出:&#x2F;&#x2F; &lt;ul id&#x3D;&quot;appleTree1&quot;&gt;..&lt;&#x2F;ul&gt;&#x2F;&#x2F; &lt;ul id&#x3D;&quot;appleTree2&quot;&gt;..&lt;&#x2F;ul&gt; 如此可以看見，我們在正確的時間點置入script標籤並使用document.getElementById取得元素節點，然後成功打印出來了 ! 由此現象可以證實，我們的瀏覽器是一行一行，由上而下的執行。 不過這麼寫就顯得有點冗雜，所以我們做最後的整理，再次依照瀏覽器一行一行，由上而下的準則，我們調整文檔內容的位置成如下: 123456789101112131415&lt;body&gt; &lt;ul id&#x3D;&quot;appleTree1&quot;&gt; &lt;li&gt;apple1&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;ul id&#x3D;&quot;appleTree2&quot;&gt; &lt;li&gt;apple2&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;script&gt; let appleTree1 &#x3D; document.getElementById(&quot;appleTree1&quot;); let appleTree2 &#x3D; document.getElementById(&quot;appleTree2&quot;); console.log(appleTree2, appleTree1); &lt;&#x2F;script&gt;&lt;&#x2F;body&gt; 123&#x2F;&#x2F; 分別輸出:&#x2F;&#x2F; &lt;ul id&#x3D;&quot;appleTree1&quot;&gt;..&lt;&#x2F;ul&gt;&#x2F;&#x2F; &lt;ul id&#x3D;&quot;appleTree2&quot;&gt;..&lt;&#x2F;ul&gt; 透過遵照瀏覽器是一行一行，由上而下的行為準則，我們移動文檔內容位置，分別讓appleTree1和appleTree2的兩個ul元素分別先被解析，接者把兩個script標籤合併為一個，一次取得appleTree1 appleTree2兩者的內容並一起打印，而且最後也順利輸出。了解瀏覽器規則，可以幫助我們寫出更簡潔，並且有邏輯性的文檔及程式碼 ! 這就是為何我們常常會聽到要把script標籤置於文檔最下方(&lt;/body&gt;之前)的理由了，由於瀏覽器此行為影響甚大，因此我們在開發網頁時，通常將script標籤置於此，以確保我們的JavaScript程式碼可以在所有的網頁元素被解析完畢後才開始執行，以避免錯誤或不預期的結果產生!。 # 結尾 第一篇文就到這裡了，算是比較簡單的內容，其實”Javasciprt 忍者開發技巧探秘 第二版 “ 這本書的目標是比較有基礎的讀者，本篇的內容也不能說和此書的開頭章節有大程度的契合性，不過大方向是一樣的，主要是想透過自己讀完一個章節，在心中自己做整理後，用自己的方式寫出由淺入深、再平易近人些的內容以及述說文字。 畢竟若我們真的去讀一些技術書刊、官方文件或網站，難免會因為英文程度問題，或者翻譯可能也無法用很白話的方式翻譯，時常會被一些生澀的文字卡住，因此希望透過自己寫的文，一方面能帶給別人一些內容，最主要是給自己有個目標，同時也能夠逼自己去讀書，理解及發現一些以前自己錯過的內容，也可鍛鍊自己的邏輯整理及文筆，於自己往後的職涯，都能有更好的發展，搞不好最後我不寫程式，跑去當部落客也不一定呢，XD。 感謝收看第一篇，下次再見。","categories":[],"tags":[{"name":"讀書心得","slug":"讀書心得","permalink":"https://korbat4625.github.io/youzi/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"}],"author":"Elvis Huang (Aka Allen)"}],"categories":[],"tags":[{"name":"讀書心得","slug":"讀書心得","permalink":"https://korbat4625.github.io/youzi/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"}]}